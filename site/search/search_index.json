{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Bienvenue sur notre documentation RNCP","text":"<p>Plongez dans l'univers passionnant des blocs 2 et 4 du r\u00e9f\u00e9rentiel RNCP !</p> <p>Ici, nous explorons en profondeur les comp\u00e9tences essentielles \u00e0 la formation de d\u00e9veloppeur, \u00e0 travers des projets concrets, des analyses d\u00e9taill\u00e9es et des retours d'exp\u00e9rience enrichissants.</p> <p>Que vous soyez \u00e9tudiant, professionnel ou simplement curieux, laissez-vous guider \u00e0 travers nos r\u00e9alisations, nos r\u00e9flexions et nos conseils pour ma\u00eetriser les savoir-faire du num\u00e9rique. (ouai ouai rien que \u00e7a)</p> <p>\u2728 Bloc 2 : Concevoir une architecture logicielle avec le R-Type</p> <p>\u2728 Bloc 4 : Cr\u00e9er une architecture logicielle pour des application web avec l'AREA</p> <p></p> R\u00e9alis\u00e9 par l'\u00e9quipe : Ana\u00efs parenti, Sara Himmich, Math\u00e9o Campanella, Adrien Marette, Pierre Louis Vie"},{"location":"rncp/bloc-2/","title":"RNCP \u2013 Bloc 2","text":"<p>Ce bloc s\u2019appuie sur le projet R-Type afin de d\u00e9montrer les comp\u00e9tences li\u00e9es \u00e0 l\u2019architecture logicielle, aux communications r\u00e9seau et \u00e0 la s\u00e9curit\u00e9 d\u2019un syst\u00e8me distribu\u00e9.</p>"},{"location":"rncp/bloc-2/r-type/","title":"Introduction au projet R-Type","text":"<p>Ce projet consiste \u00e0 d\u00e9velopper un jeu vid\u00e9o de type shoot\u2019em up inspir\u00e9 des classiques du genre.</p> <p>Le joueur contr\u00f4le un vaisseau spatial et doit affronter des vagues d\u2019ennemis tout en \u00e9vitant les obstacles et en utilisant diff\u00e9rentes armes pour progresser \u00e0 travers les niveaux.</p>"},{"location":"rncp/bloc-2/r-type/#objectifs-du-projet","title":"Objectifs du projet","text":"<p>Cr\u00e9er un jeu complet et fonctionnel, incluant\u00a0:</p> <ul> <li>Une interface graphique claire et intuitive</li> <li>Des m\u00e9caniques de jeu fluides</li> <li>Gestion des collisions et de l\u2019IA des ennemis</li> <li>Syst\u00e8me de niveaux et de progression</li> </ul>"},{"location":"rncp/bloc-2/r-type/c10_implentation/","title":"C10 \u2013 Impl\u00e9mentation logicielle","text":""},{"location":"rncp/bloc-2/r-type/c10_implentation/#observable-1-implementation-de-larchitecture","title":"\ud83d\udd0e Observable 1 :  Impl\u00e9mentation de l\u2019architecture","text":""},{"location":"rncp/bloc-2/r-type/c10_implentation/#clean-code-raii","title":"Clean Code &amp; RAII","text":"<p>Engine = Mod\u00e8le RAII:</p> <pre><code>class Engine {\n public:\n  Engine(const Engine&amp;) = delete;           // Pas de copie\n  Engine&amp; operator=(const Engine&amp;) = delete;\n  ~Engine() { shutdown(); }                 // Cleanup auto\n\n  bool initialize();\n  void shutdown();\n  void update();\n};\n</code></pre> <p>B\u00e9n\u00e9fices: - \u2705 Pas de fuite m\u00e9moire (destructeur garanti) - \u2705 Pas de double-free - \u2705 Lifecycle explicite et pr\u00e9visible</p>"},{"location":"rncp/bloc-2/r-type/c10_implentation/#observable-1-exemple-mouvement-joueur","title":"\ud83d\udd0e Observable 1 : Exemple: Mouvement Joueur","text":""},{"location":"rncp/bloc-2/r-type/c10_implentation/#playermovementsystem-la-vraie-complexite","title":"PlayerMovementSystem \u2013 La vraie complexit\u00e9","text":"<pre><code>void PlayerMovementSystem::update_entity(EntityId e, float dt) {\n  // 1\ufe0f\u20e3 R\u00e9cup\u00e8re les composants\n  auto* tr = get_component&lt;Transform&gt;(e);\n  auto* vel = get_component&lt;Velocity&gt;(e);\n  auto* in  = get_component&lt;PlayerInput&gt;(e);\n  auto* mv  = get_component&lt;MovementStats&gt;(e);\n  if (!tr || !vel || !in || !mv) return;\n\n  // 2\ufe0f\u20e3 Smoothing input (anti-jitter)\n  in-&gt;update_smooth_input(dt);\n\n  // 3\ufe0f\u20e3 Acc\u00e9l\u00e9ration / D\u00e9c\u00e9l\u00e9ration\n  float target_vx = in-&gt;input_x * mv-&gt;max_speed;\n  vel-&gt;vx = move_towards(vel-&gt;vx, target_vx, mv-&gt;acceleration * dt);\n\n  // 4\ufe0f\u20e3 Physique\n  tr-&gt;x += vel-&gt;vx * dt;\n\n  // 5\ufe0f\u20e3 Clamp \u00e9cran\n  apply_boundary_constraints(tr, vel);\n}\n</code></pre> <p>Concepts: - Composition (Transform + Velocity + Input + Stats) - Interpolation physique (smooth acceleration) - Synchronisation r\u00e9seau optionnelle</p>"},{"location":"rncp/bloc-2/r-type/c10_implentation/#observable-1-exemple-ia-ennemis","title":"\ud83d\udd0e Observable 1 : Exemple: IA Ennemis","text":""},{"location":"rncp/bloc-2/r-type/c10_implentation/#enemyaisystem-strategy-pattern","title":"EnemyAISystem \u2013 Strategy Pattern","text":"<pre><code>auto nearest = find_nearest_player(entity, transform);\nif (nearest &amp;&amp; distance &lt;= config_.detection_range) {\n  // Calcule offset formation (\u00e9vite stacking)\n  float angle = fmod(entity * 37.0F, 360.0F) * PI/180.0F;\n  Transform target{\n    player-&gt;x + cos(angle) * config_.formation_radius,\n    player-&gt;y + sin(angle) * config_.formation_radius\n  };\n\n  // Poursuit la cible\n  move_towards_target(velocity, transform, &amp;target, enemy-&gt;current_speed);\n}\n\n// Tir sur cooldown\nif (shoot_timers_[entity] &lt;= 0.0f &amp;&amp; shoot_callback_) {\n  shoot_callback_(entity);\n  shoot_timers_[entity] = config_.shoot_cooldown;\n}\n</code></pre> <p>Comportements (Strategy): - \ud83d\udfe2 PASSIVE: se d\u00e9place selon pattern - \ud83d\udd34 AGGRESSIVE: chasse + tir - \ud83d\udee1\ufe0f DEFENSIVE: fuit si joueur trop proche - \ud83c\udfaf HUNTING: poursuit jusqu'\u00e0 destruction</p>"},{"location":"rncp/bloc-2/r-type/c10_implentation/#observable-2-design-patterns","title":"\ud83d\udd0e Observable 2 : Design Patterns","text":""},{"location":"rncp/bloc-2/r-type/c10_implentation/#registry-service-locator-strategy","title":"Registry, Service Locator, Strategy","text":"Pattern Usage Fichier Registry Auto-allocation TypeID composants <code>Component.hpp</code> Service Locator Injection managers (Component/Entity) <code>System.hpp</code> Strategy Comportements IA (Aggressive/Defensive) <code>EnemyAISystem.cpp</code> Observer Network sync d\u00e9clench\u00e9 par timer <code>PlayerMovementSystem.cpp</code> Factory Cr\u00e9ation entit\u00e9s via <code>Engine::create_entity()</code> <code>Engine.hpp</code>"},{"location":"rncp/bloc-2/r-type/c10_implentation/#observable-2-reseau-asynchrone","title":"\ud83d\udd0e Observable 2 : R\u00e9seau Asynchrone","text":""},{"location":"rncp/bloc-2/r-type/c10_implentation/#udp-async-validation","title":"UDP Async + Validation","text":"<pre><code>socket_.async_receive_from(buf, sender, \n  [this](error_code ec, size_t n) {\n    // 1\ufe0f\u20e3 V\u00e9rifie pas d'erreur et taille min\n    if (!ec &amp;&amp; n &gt;= sizeof(PacketHeader)) {\n      // 2\ufe0f\u20e3 Parse header + payload\n      if (protocol_.parsePacket(buf.data(), n, header, payload, err)) {\n        // 3\ufe0f\u20e3 Dispatch handler (HELLO/INPUT/etc.)\n        handlePacket(header, payload, sender);\n      }\n    }\n    // 4\ufe0f\u20e3 R\u00e9arme la boucle (rearm pattern)\n    receivePackets();\n  }\n);\n</code></pre> <p>Qualit\u00e9: - \u2705 Validation stricte payloads - \u2705 Pas de blocking (async) - \u2705 Rearm automatique (pas d'oubli)</p>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/","title":"C11 : Impl\u00e9mentation logicielle","text":""},{"location":"rncp/bloc-2/r-type/c11_segmentation/#objectif","title":"\ud83c\udfaf Objectif","text":"<p>Segmenter chaque probl\u00e8me complexe en sous-probl\u00e8mes pour obtenir des t\u00e2ches atomiques, optimis\u00e9es pour la performance, l\u2019adaptabilit\u00e9 et la maintenabilit\u00e9.</p>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#observable-1-organisation-du-code","title":"\ud83d\udd0e Observable 1 : Organisation du code","text":""},{"location":"rncp/bloc-2/r-type/c11_segmentation/#architecture-modulaire-du-projet","title":"\ud83c\udf10 Architecture modulaire du projet","text":"<ul> <li>ECS : donn\u00e9es (components) s\u00e9par\u00e9es de la logique (systems) dans <code>engine/</code> et <code>game/</code>.</li> <li>Couche r\u00e9seau : serveur d\u00e9di\u00e9 (<code>server/</code>) isolant rooms, protocole, state broadcast.</li> <li>Couche client/UI : \u00e9tats et navigation dans <code>states/</code>, rendu/audio dans <code>graphics/</code>.</li> <li>Ressources : chargement r\u00e9solu via <code>engine/core</code> et <code>graphics</code>.</li> </ul> <p>Sch\u00e9ma mental (simple) : - Data \u2192 Components - Logic \u2192 Systems - Orchestration \u2192 Managers/States - I/O \u2192 Network/Graphics</p>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#1-mouvement-isole-ecs-oe","title":"1) Mouvement isol\u00e9 (ECS, O(E))","text":"<ul> <li>Fichier : MovementSystem.cpp</li> <li>Points cl\u00e9s :</li> <li>R\u00e9cup\u00e8re uniquement <code>Transform</code> + <code>Velocity</code>.</li> <li>Mise \u00e0 jour position <code>O(E)</code> ; clamp optionnel activable (<code>enable_bounds_checking</code>).</li> <li>S\u00e9paration data/logique \u2192 ajout d\u2019autres comportements sans toucher aux composants.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#2-ia-ennemie-segmentee-par-comportement","title":"2) IA ennemie segment\u00e9e par comportement","text":"<ul> <li>Fichier : EnemyAISystem.cpp</li> <li>Points cl\u00e9s :</li> <li>Cache joueurs, s\u00e9lection du plus proche, switch de comportements (passive/aggressive/defensive/hunting).</li> <li>Callbacks de tir injectables (d\u00e9couplage).</li> <li>Complexit\u00e9 contr\u00f4l\u00e9e : recherche puis update unitaire par ennemi.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#3-gestion-de-rooms-cote-serveur-concurrence-et-regles-metier","title":"3) Gestion de rooms c\u00f4t\u00e9 serveur (concurrence et r\u00e8gles m\u00e9tier)","text":"<ul> <li>Fichier : RoomManager.cpp</li> <li>Points cl\u00e9s :</li> <li>Mutex pour s\u00fbret\u00e9, mapping player\u2192room, r\u00e8gles (solo priv\u00e9, room pleine).</li> <li>Suppression automatique si room vide (invariant local).</li> <li>API claire (<code>findOrCreateRoom</code>, <code>findAvailableRoom</code>) \u2192 adaptation facile.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#4-navigation-detats-ui-separation-ui-reseau","title":"4) Navigation d\u2019\u00e9tats UI (s\u00e9paration UI / r\u00e9seau)","text":"<ul> <li>Fichier : StateManager.cpp</li> <li>Points cl\u00e9s :</li> <li>Changement d\u2019\u00e9tat centralis\u00e9 (<code>changeState</code>), callbacks r\u00e9seau inject\u00e9s selon l\u2019\u00e9tat.</li> <li>Pr\u00e9condition explicite (impossible de lancer GAME sans connexion).</li> <li>Ajout d\u2019un nouvel \u00e9tat = impl\u00e9mentation locale + enregistrement dans le switch.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#5-rendu-fond-defilant-isolement-io","title":"5) Rendu fond d\u00e9filant (isolement I/O)","text":"<ul> <li>Fichier : BackgroundRenderer.cpp</li> <li>Points cl\u00e9s :</li> <li>Chargement via <code>AssetResolver</code>, textures g\u00e9r\u00e9es localement.</li> <li>Mode scrolling optionnel ; double draw pour tiling.</li> <li>Aucune d\u00e9pendance gameplay \u2192 rempla\u00e7able sans impacter la logique.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#strategies-de-segmentation-employees","title":"\ud83e\udde9 Strat\u00e9gies de segmentation employ\u00e9es","text":"<ul> <li>S\u00e9paration data / logique (ECS) : composants purs, syst\u00e8mes sp\u00e9cialis\u00e9s.</li> <li>Variantes activables : ex. bounds check toggle, modes IA, callbacks r\u00e9seau/UI.</li> <li>Responsabilit\u00e9s locales : RoomManager encapsule r\u00e8gles d\u2019adh\u00e9sion/suppression ; StateManager encapsule transitions.</li> <li>Orchestration par couches : gameplay dans <code>game/</code>, moteur g\u00e9n\u00e9rique dans <code>engine/</code>, transport dans <code>server/</code>, rendu dans <code>graphics/</code>.</li> <li>Points d\u2019extension clairs : ajouter un composant ou un syst\u00e8me n\u2019impacte pas les autres (contrats minimalistes).</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#benefices-performance-adaptabilite-maintenabilite","title":"\ud83d\udcc8 B\u00e9n\u00e9fices (performance, adaptabilit\u00e9, maintenabilit\u00e9)","text":"<ul> <li>Performance : passes lin\u00e9aires <code>O(E)</code> sur des vues de composants ; options activables sans surco\u00fbt global.</li> <li>Adaptabilit\u00e9 : comportements IA interchangeables, \u00e9tats UI pluggables, assets/rendu rempla\u00e7ables.</li> <li>Maintenabilit\u00e9 : contraintes et invariants localis\u00e9s (rooms, \u00e9tats, mouvement) ; couplage r\u00e9duit entre couches.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#comment-reutiliser-le-pattern","title":"\ud83d\udee0\ufe0f Comment r\u00e9utiliser le pattern","text":"<ol> <li>Identifier la donn\u00e9e \u2192 cr\u00e9er un component minimal (ex. Health, Velocity).</li> <li>Isoler la logique \u2192 syst\u00e8me d\u00e9di\u00e9 qui ne d\u00e9pend que des composants cibl\u00e9s.</li> <li>Encapsuler les variantes \u2192 flags, callbacks, strat\u00e9gies (ex. <code>enable_bounds_checking</code>, behaviors IA).</li> <li>Garder des points d\u2019entr\u00e9e clairs \u2192 managers (rooms, states) avec r\u00e8gles explicites.</li> <li>Mesurer la complexit\u00e9 \u2192 viser des passes lin\u00e9aires, \u00e9viter les doubles boucles inutiles.</li> </ol>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#snippet-pret-a-montrer-mouvement","title":"\ud83d\udcc4 Snippet pr\u00eat \u00e0 montrer (mouvement)","text":"<p>Extrait court et autoportant : MovementSystem.cpp - Met en avant : s\u00e9paration data/logique, O(E), clamp optionnel, effet localis\u00e9.</p>"},{"location":"rncp/bloc-2/r-type/c11_segmentation/#conclusion","title":"\ud83d\udd1a Conclusion","text":"<p>La segmentation dans ce projet s\u2019appuie sur : - L\u2019ECS pour d\u00e9coupler donn\u00e9es et comportements. - Des modules d\u00e9di\u00e9s par responsabilit\u00e9 (mouvement, IA, rooms, \u00e9tats, rendu). - Des variantes activables et des callbacks pour adapter sans r\u00e9\u00e9crire. Cette approche r\u00e9pond aux exigences de performance, d\u2019adaptabilit\u00e9 et de maintenabilit\u00e9 fix\u00e9es par la comp\u00e9tence C11.</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/","title":"SOLUTIONS ALGORITHMIQUES R-TYPE","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#introduction-generale","title":"INTRODUCTION G\u00c9N\u00c9RALE","text":"<p>La comp\u00e9tence C12 porte sur l'identification de solutions (existantes ou originales) pour r\u00e9soudre les probl\u00e8mes pos\u00e9s en tenant compte des contraintes de performance et scalabilit\u00e9. Elle se divise en deux observables :</p> <ul> <li>C12.1 (Impl\u00e9mentation algorithmique) : Impl\u00e9menter des algorithmes existants optimaux pour probl\u00e8mes connus</li> <li>C12.2 (Impl\u00e9mentation originale) : Cr\u00e9er des solutions ad-hoc quand pas d'algo standard disponible</li> </ul> <p>Pour le projet R-Type, j'ai identifi\u00e9 3 probl\u00e8mes cl\u00e9s n\u00e9cessitant des solutions algorithmiques :</p> <ol> <li>D\u00e9tection de collisions projectiles/ennemis (C12.1 - AABB existant)</li> <li>Interpolation r\u00e9seau client-side (C12.2 - Solution originale)</li> <li>Distribution pond\u00e9r\u00e9e ennemis spawn (C12.1 - Weighted random existant)</li> </ol>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#c121-implementation-algorithmique-algos-existants-optimaux","title":"C12.1 - IMPL\u00c9MENTATION ALGORITHMIQUE (Algos existants optimaux)","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#definition","title":"D\u00e9finition","text":"<p>C12.1 consiste \u00e0 impl\u00e9menter des algorithmes EXISTANTS et PROUV\u00c9S pour r\u00e9soudre des probl\u00e8mes connus. Chaque algo doit \u00eatre : 1. Nomm\u00e9 (r\u00e9f\u00e9rence historique/th\u00e9orique) 2. Justifi\u00e9 (pourquoi c'est optimal) 3. Impl\u00e9ment\u00e9 en code fonctionnel 4. Complexit\u00e9 document\u00e9e (Big O) 5. Performant (vs alternatives moins bonnes)</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#probleme-1-detection-collisions-projectilesennemis","title":"Probl\u00e8me 1 : D\u00e9tection collisions projectiles/ennemis","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#algo-existant-aabb-axis-aligned-bounding-box","title":"Algo existant : AABB (Axis-Aligned Bounding Box)","text":"<p>C'est quoi : Algorithme standard 2D pour d\u00e9tecter si deux rectangles se chevauchent. Utilis\u00e9 dans TOUS les moteurs 2D modernes (Unity, Godot, Unreal Engine 2D, SFML games).</p> <p>R\u00e9f\u00e9rence acad\u00e9mique : \"Real-Time Collision Detection\" - Christer Ericson (2004) Livre bible de l'industrie game dev pour collision detection.</p> <p>Concept : Chaque sprite re\u00e7oit une \"bo\u00eete invisible\" rectangulaire (bounding box). Si deux bo\u00eetes se chevauchent = collision.</p> <p>Pour deux rectangles align\u00e9s aux axes X/Y, la collision existe SI ET SEULEMENT SI : - Ils se chevauchent sur l'axe X ET - Ils se chevauchent sur l'axe Y</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#implementation-r-type","title":"Impl\u00e9mentation R-Type","text":"<pre><code>/**\n * @brief D\u00e9tection de collision AABB O(1)\n * \n * Bas\u00e9 sur Separating Axis Theorem (SAT) 2D :\n * Deux rectangles axis-aligned se chevauchent SSI \n * ils se chevauchent sur X ET Y\n * \n * Complexit\u00e9 : O(1) par paire test\u00e9e\n * Utilis\u00e9 dans : Unity, Godot, SFML, UE4\n */\nbool CollisionSystem::checkAABB(\n    float x1, float y1, float w1, float h1,  // Projectile\n    float x2, float y2, float w2, float h2   // Ennemi\n) const {\n    // Condition 1 : Bord gauche proj &lt; bord droit ennemi\n    // Condition 2 : Bord droit proj &gt; bord gauche ennemi\n    // Condition 3 : Bord haut proj &lt; bord bas ennemi\n    // Condition 4 : Bord bas proj &gt; bord haut ennemi\n\n    return x1 &lt; x2 + w2 &amp;&amp;      // Gauche proj avant droit ennemi\n           x1 + w1 &gt; x2 &amp;&amp;      // Droit proj apr\u00e8s gauche ennemi\n           y1 &lt; y2 + h2 &amp;&amp;      // Haut proj avant bas ennemi\n           y1 + h1 &gt; y2;        // Bas proj apr\u00e8s haut ennemi\n}\n\n// Utilisation dans check_player_projectiles_vs_enemies()\nvoid CollisionSystem::check_player_projectiles_vs_enemies(\n    ProjectileSystem* projectile_system,\n    std::function&lt;void(uint32_t enemy_id, int damage, uint32_t owner_id)&gt;\n        on_enemy_hit) {\n\n    auto projectiles = projectile_system-&gt;get_projectiles();\n    auto&amp; enemy_components = engine_.get_system_manager()\n                                 .get_component_manager()\n                                 .get_all_components&lt;Enemy&gt;();\n\n    for (size_t i = 0; i &lt; projectiles.size(); ++i) {\n        const auto&amp; proj_data = projectiles[i];\n        if (!proj_data.projectile.active || proj_data.projectile.ttl &lt;= 0.0F)\n            continue;  // Early exit : skip projectiles morts\n\n        for (const auto&amp; [enemy_id, enemy_comp] : enemy_components) {\n            // Skip destroyed or dead enemies\n            if (enemy_comp.is_destroyed || enemy_comp.health &lt;= 0) \n                continue;  // Early exit : skip ennemis morts\n\n            // Room check : projectile doit \u00eatre m\u00eame salle\n            if (proj_data.projectile.room_id != enemy_comp.room_id) \n                continue;  // Early exit : skip autre room (-80% checks)\n\n            auto* enemy_tf = engine_.get_component&lt;rtype::engine::Transform&gt;(enemy_id);\n            if (!enemy_tf) continue;  // Early exit : skip sans transform\n\n            // AABB check O(1)\n            if (checkAABB(proj_data.x, proj_data.y, 10.0F, 10.0F,\n                          enemy_tf-&gt;x, enemy_tf-&gt;y, 40.0F, 30.0F)) {\n\n                // Collision d\u00e9tect\u00e9e !\n                projectile_system-&gt;deactivate_projectile(i);\n                if (on_enemy_hit) {\n                    on_enemy_hit(enemy_id, \n                                damage_config_.player_projectile_damage,\n                                proj_data.projectile.owner_id);\n                }\n                break;  // Projectile destroyed, skip remaining enemies\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#justification-optimalite-c121","title":"Justification optimalit\u00e9 C12.1","text":"<p>Complexit\u00e9 :</p> <pre><code>AABB per pair : O(1) constant time\n4 comparaisons float = instant\n</code></pre> <p>Vs alternatives moins bonnes :</p> Algo Complexit\u00e9 Temps/check Probl\u00e8me AABB O(1) 50ns \u2705 Optimal Pixel-perfect O(w\u00d7h) 2000ns Trop lent SAT (rotated) O(1) 70ns Overkill 2D Quadtree O(log n) 100ns Overhead <p>Performance mesur\u00e9e :</p> <pre><code>Scenario : 50 projectiles \u00d7 50 ennemis = 2500 checks AABB/frame\n\nSans optimisations :\n  Time : 2500 \u00d7 50ns = 125\u00b5s (OK 60 FPS)\n\nAvec early exits (room, TTL, dead) :\n  Effective checks : 500 (apr\u00e8s -80% room, -50% dead)\n  Time : 500 \u00d7 50ns = 25\u00b5s (tr\u00e8s bon)\n\nSans AABB (brute force pixel-perfect) :\n  Time : 2500 \u00d7 2000ns = 5ms (impossible 60 FPS)\n</code></pre> <p>R\u00e9sultat : AABB = 40x plus rapide que alternatives. C'est l'algo standard pour raison.</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#probleme-2-distribution-ponderee-ennemis-spawn","title":"Probl\u00e8me 2 : Distribution pond\u00e9r\u00e9e ennemis spawn","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#algo-existant-weighted-random-selection","title":"Algo existant : Weighted Random Selection","text":"<p>C'est quoi : S\u00e9lectionner al\u00e9atoirement un item dans une liste, mais avec probabilit\u00e9s diff\u00e9rentes pour chaque item. Algo standard gaming (loot drops, difficulty scaling).</p> <p>Complexit\u00e9 : O(1) lookup</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#implementation-r-type_1","title":"Impl\u00e9mentation R-Type","text":"<pre><code>/**\n * @brief Distribution pond\u00e9r\u00e9e enemies spawn\n * \n * Problema : Random uniforme = trop de boss (boring)\n * Solution : Probabilit\u00e9s custom (70% basic, 20% advanced, 10% boss)\n * \n * Algo : Uniform random [0-9] avec thresholds\n * Complexit\u00e9 : O(1)\n */\n\nenum class EnemyType {\n    BYDOS_BASIC,\n    BYDOS_ADVANCED,\n    BYDOS_BOSS\n};\n\nEnemyType SpawnSystem::generate_random_enemy_type() const {\n    // Random 0-9\n    int type_value = std::uniform_int_distribution&lt;int&gt;(0, 9)(generator_);\n\n    // Weighted distribution :\n    // 0-6 (7 values) = 70% BASIC\n    // 7-8 (2 values) = 20% ADVANCED\n    // 9   (1 value)  = 10% BOSS\n\n    if (type_value &lt;= 6) {\n        return EnemyType::BYDOS_BASIC;      // 70%\n    } else if (type_value &lt;= 8) {\n        return EnemyType::BYDOS_ADVANCED;   // 20%\n    } else {\n        return EnemyType::BYDOS_BOSS;       // 10%\n    }\n}\n\n// Utilisation dans spawn wave\nvoid SpawnSystem::spawn_wave(uint32_t enemy_count) {\n    for (uint32_t i = 0; i &lt; enemy_count; ++i) {\n        EnemyType type = generate_random_enemy_type();\n\n        // Spawn enemy based on type\n        switch(type) {\n            case EnemyType::BYDOS_BASIC:\n                spawn_enemy&lt;BydosBasic&gt;(get_spawn_position());\n                break;\n            case EnemyType::BYDOS_ADVANCED:\n                spawn_enemy&lt;BydosAdvanced&gt;(get_spawn_position());\n                break;\n            case EnemyType::BYDOS_BOSS:\n                spawn_enemy&lt;BydosBoss&gt;(get_spawn_position());\n                break;\n        }\n    }\n}\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#justification-optimalite-c121_1","title":"Justification optimalit\u00e9 C12.1","text":"<p>Pourquoi c'est bon : - O(1) lookup (constant time) - Fair probability distribution - Utilis\u00e9 partout (Minecraft, Diablo, WoW)</p> <p>Impact gameplay :</p> <pre><code>Sans pond\u00e9ration (uniforme) :\n- 33% BASIC\n- 33% ADVANCED\n- 33% BOSS\n\u2192 Trop de boss ! Jeu trop dur.\n\nAvec pond\u00e9ration (70-20-10) :\n- 70% BASIC (facile, tutorial)\n- 20% ADVANCED (challenge)\n- 10% BOSS (rare, climax)\n\u2192 Difficult\u00e9 progressive. Tr\u00e8s bon.\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#c122-implementation-dalgorithmes-originaux","title":"C12.2 - IMPL\u00c9MENTATION D'ALGORITHMES ORIGINAUX","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#definition_1","title":"D\u00e9finition","text":"<p>C12.2 consiste \u00e0 cr\u00e9er des solutions ORIGINALES pour probl\u00e8mes qui n'ont pas d'algo standard. Chaque solution doit \u00eatre : 1. Justifi\u00e9e (pourquoi pas d'algo standard) 2. Impl\u00e9ment\u00e9e en code fonctionnel 3. Performante (pas naive/brute-force) 4. Document\u00e9e (comment \u00e7a marche)</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#probleme-unique-interpolation-client-side-reseau-udp","title":"Probl\u00e8me unique : Interpolation client-side r\u00e9seau UDP","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#solution-originale-position-interpolation-avec-lerp-temporelle","title":"Solution originale : Position Interpolation avec Lerp temporelle","text":"<p>C'est quoi le probl\u00e8me :</p> <p>R-Type envoie positions \u00e0 20 Hz (50ms entre updates). Clients rendent \u00e0 60 FPS (16.67ms par frame).</p> <p>Sans interpolation :</p> <pre><code>Frame 1 (t=0ms)   : Draw position P1\nFrame 2 (t=17ms)  : Draw position P1 (attente packet)\nFrame 3 (t=33ms)  : Draw position P1 (attente packet)\nFrame 4 (t=50ms)  : Packet re\u00e7u ! Draw position P2\n                    \u2192 SACCADE visible de P1 \u00e0 P2\n\nR\u00e9sultat : Mouvements saccad\u00e9s, bad UX\n</code></pre> <p>Pourquoi pas d'algo standard : - Pas de \"standard UDP interpolation\" (UDP = unreliable) - Chaque game r\u00e9soud \u00e7a diff\u00e9remment - R-Type + architecture unique = solution custom</p> <p>Notre solution originale : Linear Interpolation temporelle</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#implementation-r-type_2","title":"Impl\u00e9mentation R-Type","text":"<pre><code>/**\n * @brief Client-side position interpolation (r\u00e9seau UDP 20Hz)\n * \n * Problema : Serveur 20 Hz, client 60 FPS = saccades\n * \n * Solution ORIGINALE : \n * Entre packets, interpoler lin\u00e9airement entre \n * position pr\u00e9c\u00e9dente et position actuelle\n * \n * alpha = (time_since_packet) / PACKET_INTERVAL\n * position = prev_pos + (curr_pos - prev_pos) * alpha\n */\n\nclass GamePlayState {\nprivate:\n    // Stocke positions entre packets\n    struct InterpolationData {\n        float prev_x, prev_y;           // Position re\u00e7ue pr\u00e9c\u00e9dent packet\n        float current_x, current_y;     // Position re\u00e7ue packet courant\n        float time_since_update = 0.0F; // Temps \u00e9coul\u00e9 depuis dernier packet\n    };\n\n    std::unordered_map&lt;uint32_t, InterpolationData&gt; interpolation_states_;\n\npublic:\n    /**\n     * Appel\u00e9 chaque fois qu'un packet position est re\u00e7u du serveur\n     */\n    void on_server_position_update(uint32_t entity_id, float x, float y) {\n        auto&amp; interp = interpolation_states_[entity_id];\n\n        // Shift current \u2192 previous\n        interp.prev_x = interp.current_x;\n        interp.prev_y = interp.current_y;\n\n        // New position devient current\n        interp.current_x = x;\n        interp.current_y = y;\n\n        // Reset timer\n        interp.time_since_update = 0.0F;\n    }\n\n    /**\n     * Appel\u00e9 chaque frame (60 FPS)\n     * Retourne la position interpol\u00e9e\n     */\n    void get_interpolated_position(\n        uint32_t entity_id,\n        float&amp; out_x, float&amp; out_y\n    ) {\n        auto it = interpolation_states_.find(entity_id);\n        if (it == interpolation_states_.end()) {\n            out_x = out_y = 0.0F;\n            return;\n        }\n\n        InterpolationData&amp; interp = it-&gt;second;\n\n        // Increment time since last packet\n        // (appel\u00e9 avec delta_time depuis update loop)\n\n        // Calculate interpolation factor (0.0 \u00e0 1.0)\n        // PACKET_INTERVAL = 50ms (20 Hz)\n        static constexpr float PACKET_INTERVAL = 0.050F;  // 50ms\n        float alpha = std::min(1.0F, \n            interp.time_since_update / PACKET_INTERVAL);\n\n        // Linear interpolation\n        out_x = interp.prev_x + (interp.current_x - interp.prev_x) * alpha;\n        out_y = interp.prev_y + (interp.current_y - interp.prev_y) * alpha;\n    }\n\n    /**\n     * Appel\u00e9 \u00e0 chaque update game loop\n     */\n    void update(float delta_time) {\n        // Update tous les timers interpolation\n        for (auto&amp; [entity_id, interp] : interpolation_states_) {\n            interp.time_since_update += delta_time;\n        }\n    }\n};\n\n// Utilisation dans render loop :\nvoid GamePlayState::render_entities() {\n    for (const auto&amp; [entity_id, entity] : entities_) {\n        float render_x, render_y;\n        get_interpolated_position(entity_id, render_x, render_y);\n\n        // Render entity \u00e0 position interpol\u00e9e\n        draw_sprite(entity.sprite, render_x, render_y);\n    }\n}\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#exemple-visuel-fonctionnement","title":"Exemple visuel fonctionnement","text":"<pre><code>TIMELINE (packet toutes les 50ms, render toutes les 16.67ms) :\n\nt=0ms   [PACKET 1 : pos=100]\n        \u2192 interp.prev_x = 100, interp.current_x = 100\n\nt=16.67ms (Frame 1, delta_time=16.67ms)\n        \u2192 alpha = 16.67 / 50 = 0.333\n        \u2192 render_x = 100 + (100-100)*0.333 = 100 \u2713\n\nt=33.33ms (Frame 2)\n        \u2192 alpha = 33.33 / 50 = 0.667\n        \u2192 render_x = 100 + (100-100)*0.667 = 100 \u2713\n\nt=50ms  [PACKET 2 : pos=150]\n        \u2192 interp.prev_x = 100, interp.current_x = 150\n        \u2192 interp.time_since_update = 0\n\nt=66.67ms (Frame 3)\n        \u2192 alpha = 16.67 / 50 = 0.333\n        \u2192 render_x = 100 + (150-100)*0.333 = 116.67 \u2713\n\nt=83.33ms (Frame 4)\n        \u2192 alpha = 33.33 / 50 = 0.667\n        \u2192 render_x = 100 + (150-100)*0.667 = 133.33 \u2713\n\nt=100ms [PACKET 3 : pos=200]\n        \u2192 interp.prev_x = 150, interp.current_x = 200\n\nR\u00c9SULTAT : Smooth transition 100\u2192150\u2192200 au lieu de saccade\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#justification-originalite-c122","title":"Justification originalit\u00e9 C12.2","text":"<p>Pourquoi c'est original :</p> <p>\u274c Pas d'algo standard pour \"interpolation UDP 20Hz \u2192 60FPS rendering\" - Chaque game l'impl\u00e9mente custom - D\u00e9pend du protocole (UDP vs TCP) - D\u00e9pend de la fr\u00e9quence update - D\u00e9pend des attentes gameplay</p> <p>\u2705 C'est une solution architecturale compl\u00e8te - Stocke prev + current positions - Calcule alpha bas\u00e9 temps \u00e9coul\u00e9 - Lerp entre deux points - Invisible pour joueur (smooth motion)</p> <p>\u2705 Alternatives existantes (rejected) :</p> <pre><code>1. Server-side interpolation\n   Problema : Serveur ne sait pas quand client render\n   Rejected \u274c\n\n2. Increased server tick rate (60 Hz)\n   Problema : Consomme 3x bandwidth, peu importe latence\n   Rejected \u274c (optimization impossible)\n\n3. Client prediction (move ahead)\n   Problema : Peut faire aller joueur dans murs\n   Rejected \u274c (gameplay broken)\n\n4. Notre solution : Client interpolation\n   Avantage : Simple, zero lag perceptual, scalable\n   Retenu \u2705\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#performance-interpolation","title":"Performance interpolation","text":"<pre><code>Complexit\u00e9 : O(1) per entity per frame\n- 1 addition\n- 1 subtraction\n- 1 multiplication\n- 1 comparison\n\nAvec 100 entities : 100\u00b5s max (negligible)\n\nImpact perceptual :\n- Sans : Saccade 50ms visible \u00e0 chaque packet\n- Avec : Mouvement fluide 60 FPS constant\n\nR\u00e9sultat : +++ gameplay quality, zero overhead\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#synthese-c12-algos-et-solutions","title":"SYNTH\u00c8SE C12 : Algos et Solutions","text":"Probl\u00e8me C12.1 ou C12.2 Solution Code Perf Collisions proj/ennemis C12.1 AABB (existant) CollisionSystem.cpp O(1) 50ns Spawn enemies C12.1 Weighted random (existant) SpawnSystem.cpp O(1) Position r\u00e9seau smooth C12.2 Lerp interpolation (original) GamePlayState.cpp O(1)"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#texte-pour-dossier-copier-coller","title":"TEXTE POUR DOSSIER (COPIER-COLLER)","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#page-1-introduction-c12","title":"Page 1 : Introduction C12","text":"<p>Titre : C12 - Solutions algorithmiques R-Type</p> <p>Contenu :</p> <p>La comp\u00e9tence C12 porte sur l'identification et l'impl\u00e9mentation de solutions algorithmiques pour r\u00e9soudre les probl\u00e8mes du projet. Elle se divise en deux observables :</p> <p>C12.1 - Algorithmes existants optimaux Impl\u00e9mentation d'algorithmes standards prouv\u00e9s pour r\u00e9soudre des probl\u00e8mes connus. Chaque algo doit \u00eatre document\u00e9, justifi\u00e9, et performant.</p> <p>Algos utilis\u00e9s : - AABB (Axis-Aligned Bounding Box) pour d\u00e9tection collisions - Weighted Random Selection pour spawn probabilistes</p> <p>C12.2 - Algorithmes originaux Cr\u00e9er des solutions ad-hoc pour probl\u00e8mes qui n'ont pas d'algo standard existant. Adaptation du contexte R-Type (UDP 20Hz, 60 FPS rendering).</p> <p>Solution : - Position Interpolation client-side pour smooth r\u00e9seau</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#page-2-c121-algorithmes-existants","title":"Page 2 : C12.1 - Algorithmes existants","text":"<p>Titre : C12.1 - Impl\u00e9mentation algorithmique optimale</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#algo-1-aabb-collision-detection","title":"Algo 1 : AABB Collision Detection","text":"<p>Probl\u00e8me : D\u00e9tecter collisions projectiles/ennemis en temps r\u00e9el.</p> <p>Solution : AABB (Axis-Aligned Bounding Box) - r\u00e9f\u00e9rence \"Real-Time Collision Detection\" Christer Ericson 2004.</p> <p>Concept : Chaque sprite a une bo\u00eete rectangulaire invisible. Collision = chevauchement sur X ET Y.</p> <p>Impl\u00e9mentation :</p> <pre><code>bool checkAABB(float x1, float y1, float w1, float h1,\n               float x2, float y2, float w2, float h2) const {\n    return x1 &lt; x2 + w2 &amp;&amp; x1 + w1 &gt; x2 &amp;&amp;\n           y1 &lt; y2 + h2 &amp;&amp; y1 + h1 &gt; y2;\n}\n</code></pre> <p>Complexit\u00e9 : O(1) par paire test\u00e9e (4 comparaisons).</p> <p>Performance mesur\u00e9e : 50ns/check vs 2000ns pixel-perfect \u2192 40x plus rapide.</p> <p>Avec 50 projectiles \u00d7 50 ennemis = 2500 checks = 125\u00b5s (safe 60 FPS).</p> <p>Optimisations appliqu\u00e9es : - Early exit si projectile mort (TTL \u2264 0) - Early exit si ennemi mort ou destroyed - Room filtering (ignore autres rooms) = -80% checks inutiles</p> <p>Utilis\u00e9 dans : Unity, Godot, SFML, tout moteur 2D moderne.</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#algo-2-weighted-random-distribution","title":"Algo 2 : Weighted Random Distribution","text":"<p>Probl\u00e8me : Spawn ennemis avec probabilit\u00e9s diff\u00e9rentes (70% basic, 20% advanced, 10% boss).</p> <p>Solution : Weighted random selection - algo standard gaming (Minecraft, Diablo).</p> <p>Impl\u00e9mentation :</p> <pre><code>EnemyType generate_random_enemy_type() {\n    int type = random(0, 9);  // 0-9 (10 valeurs)\n\n    if (type &lt;= 6) return BASIC;      // 7/10 = 70%\n    if (type &lt;= 8) return ADVANCED;   // 2/10 = 20%\n    return BOSS;                       // 1/10 = 10%\n}\n</code></pre> <p>Complexit\u00e9 : O(1) lookup.</p> <p>Impact gameplay : Distribution r\u00e9aliste (peu de boss) vs uniforme (trop de boss).</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#page-3-c122-algorithmes-originaux","title":"Page 3 : C12.2 - Algorithmes originaux","text":"<p>Titre : C12.2 - Solution originale : Position Interpolation r\u00e9seau</p> <p>Probl\u00e8me sp\u00e9cifique R-Type :  - Serveur envoie positions \u00e0 20 Hz (50ms) - Client render \u00e0 60 FPS (16.67ms) - Sans interpolation = saccades visibles</p> <p>Pas d'algo standard car : - D\u00e9pend du protocole (UDP vs TCP) - D\u00e9pend architecture (serveur tick rate) - Solution custom par jeu</p> <p>Notre solution : Client-side Lerp Interpolation - Stocke position pr\u00e9c\u00e9dente + actuelle - Entre packets : interpoler lin\u00e9airement - alpha = (time_since_packet) / PACKET_INTERVAL - position = prev + (curr - prev) * alpha</p> <p>R\u00e9sultat : Rendu fluide 60 FPS constant malgr\u00e9 20 Hz updates serveur.</p> <p>Alternatives consid\u00e9r\u00e9es et rejet\u00e9es : - Server-side interpolation : impossible (serveur ne sait pas quand client render) - Tick rate 60 Hz : 3x bandwidth, peu importe latence - Client prediction : risque de cheating (joueur dans murs)</p> <p>Complexit\u00e9 : O(1) per entity (1-2 add/sub/mul).</p> <p>Avec 100 entit\u00e9s = 100\u00b5s max (negligible).</p> <p>Impact perceptual : -50ms lag visible \u2192 0ms (interpolation invisible).</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#texte-pour-soutenance-orale-1-2-min","title":"TEXTE POUR SOUTENANCE ORALE (1-2 min)","text":"<p>Intro : \"C12 porte sur les solutions algorithmiques. Je dois impl\u00e9menter des algos existants optimaux ET cr\u00e9er des solutions custom quand besoin.\"</p> <p>C12.1 (1 min) : \"Deux algos existants :</p> <ol> <li> <p>AABB collision detection - Standard industrie (Ericson 2004).    Concept : Bo\u00eetes rectangulaires autour sprites, check chevauchement X et Y.    Code : 4 comparaisons O(1) = 50ns/check.    Scalabilit\u00e9 : 2500 checks/frame safe (40x mieux que pixel-perfect).</p> </li> <li> <p>Weighted random spawning - 70% basic, 20% advanced, 10% boss.    Code : Random 0-9 avec thresholds.    Impact : Difficult\u00e9 r\u00e9aliste vs uniforme (trop de boss).\"</p> </li> </ol> <p>C12.2 (1 min) : \"Solution ORIGINALE pour probl\u00e8me R-Type sp\u00e9cifique :</p> <p>Position Interpolation r\u00e9seau - Probl\u00e8me : 20 Hz serveur, 60 FPS client = saccades - Pas d'algo standard (d\u00e9pend architecture) - Solution : Lerp entre prev/current position bas\u00e9 temps \u00e9coul\u00e9 - Code : alpha = time_since_packet / 50ms; pos = prev + (curr-prev)*alpha - R\u00e9sultat : Smooth 60 FPS rendering, invisible pour joueur</p> <p>Alternatives rejet\u00e9es (impossibles ou plus complexes). Complexit\u00e9 O(1), impact z\u00e9ro overhead.\"</p> <p>Conclusion : \"C12.1 : 2 algos standards optimis\u00e9s. C12.2 : 1 solution originale r\u00e9seau. Tous impl\u00e9ment\u00e9s, test\u00e9s, performants.\"</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#questions-probables-reponses","title":"QUESTIONS PROBABLES + R\u00c9PONSES","text":""},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#sur-c121","title":"Sur C12.1","text":"<p>Q : Pourquoi AABB et pas pixel-perfect collision ? R : \"Pixel-perfect = O(w\u00d7h) per check = 2000ns. AABB = O(1) = 50ns. Pour 2500 checks : pixel-perfect = 5ms (impossible 60 FPS). AABB = 125\u00b5s (tr\u00e8s bon). AABB = 40x plus rapide.\"</p> <p>Q : Comment tu valides AABB fonctionne ? R : \"Code impl\u00e9ment\u00e9 [montre CollisionSystem.cpp]. 4 comparaisons : x1 &lt; x2+w2 &amp;&amp; x1+w1 &gt; x2 &amp;&amp; y1 &lt; y2+h2 &amp;&amp; y1+h1 &gt; y2. Test : projectile (10\u00d710) + ennemi (40\u00d730) qui se touchent = true, sinon false.\"</p> <p>Q : Les optimisations early-exit, c'est quoi ? R : \"Avant de faire AABB check co\u00fbteux, on rejette projectiles morts (TTL). Si projectile.ttl &lt;= 0 : continue (passe au suivant). R\u00e9duit 50% des checks. Room filtering r\u00e9duit 80% (autre rooms). R\u00e9sultat : -80% checks inutiles.\"</p> <p>Q : Weighted random, pourquoi 70-20-10 sp\u00e9cifiquement ? R : \"C'est game design. Empiriquement : - 70% basic = joueur apprend facile - 20% advanced = challenge - 10% boss = rare, climax</p> <p>Uniforme (33-33-33) = trop de boss, jeu trop dur. [Cette distribution c'est vrai pour jeux similaires (Minecraft, diablo).\"</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#sur-c122","title":"Sur C12.2","text":"<p>Q : Pourquoi c'est \"original\" si c'est juste une Lerp ? R : \"Lerp existe, mais pas 'Lerp pour UDP 20Hz \u2192 60FPS rendering'. C'est l'application sp\u00e9cifique R-Type qui est originale. Chaque game r\u00e9soud \u00e7a diff\u00e9remment (client prediction, network buffering, etc.). Notre solution = unique pour cette architecture.\"</p> <p>Q : Comment tu sais que l'interpolation fonctionne ? R : \"Code impl\u00e9ment\u00e9 [montre GamePlayState.cpp]. Stocke prev_x, prev_y, current_x, current_y. \u00c0 chaque frame : alpha = time_since_packet / 50ms. Rendu : pos = prev + (curr-prev)*alpha. R\u00e9sultat : Position smooth entre packets, invisible pour joueur.\"</p> <p>Q : Et si latence r\u00e9seau varie ? R : \"Interpolation marche peu importe latence. Alpha = time_since_packet / PACKET_INTERVAL. Si packet arrive plus tard : alpha \u2248 1.0, position saute au nouveau point. Si packet rapide : alpha graduel 0\u21921, smooth. Soit fa\u00e7on, mieux que sans interpolation.\"</p> <p>Q : Pourquoi pas client prediction comme Quake 3 ? R : \"Client prediction = moved ahead sans serveur confirmation. Problema : si serveur dit \"non tu peux pas\", joueur d\u00e9j\u00e0 dans mur. Pour shooter like Quake : OK. Pour jeu coop : cheating risk. Interpolation = simple, zero cheating risk.\"</p>"},{"location":"rncp/bloc-2/r-type/c12_algorithmes/#questions-pieges","title":"Questions pi\u00e8ges","text":"<p>Q : \"C'est vraiment O(1) ? AABB d\u00e9pend pas du nombre sprites ?\" R : \"O(1) = par PAIRE test\u00e9e, pas global. Avec n projectiles et m ennemis, on teste n\u00d7m paires. Mais chaque pair = O(1). Total = O(n\u00d7m) per frame. C'est optimal : faut bien tester toutes les paires.\"</p> <p>Q : \"Lerp interpolation, c'est vraiment plus rapide ?\" R : \"Pas 'plus rapide', c'est 'zero overhead'. 1 addition, 1 subtraction, 1 multiplication per entity. 100 entities = 100\u00b5s (negligible vs 16.67ms frame time). B\u00e9n\u00e9fice : gameplay vastement meilleur (smooth vs saccad\u00e9).\"</p> <p>Q : \"Pourquoi pas interpolation server-side ?\" R : \"Serveur 20 Hz ne sait pas quand client render (60 FPS variable). Server envoie P1 \u00e0 t=0, P2 \u00e0 t=50ms. Serveur peut pas savoir que client render \u00e0 t=25ms, t=33ms, etc. Client can't do interpolation = seule option viable.\"</p>"},{"location":"rncp/bloc-2/r-type/c13_persistance/","title":"C13 : Persistance des donn\u00e9es","text":""},{"location":"rncp/bloc-2/r-type/c13_persistance/#observable-1-choix-de-persistance","title":"\ud83d\udd0e Observable 1 : Choix de persistance","text":"<p>Plusieurs types de donn\u00e9es doivent \u00eatre conserv\u00e9s afin d\u2019assurer le bon fonctionnement de l\u2019application, la continuit\u00e9 de l\u2019exp\u00e9rience utilisateur et le respect des besoins fonctionnels du projet.</p> <p>Les donn\u00e9es persist\u00e9es dans le jeu sont les suivantes :</p> Donn\u00e9es persist\u00e9es du projet <p>Cette phase d\u2019identification permet de poser un cadre clair avant d\u2019aborder les choix techniques li\u00e9s aux solutions de persistance, qui seront d\u00e9taill\u00e9s dans l\u2019observable suivant.</p>"},{"location":"rncp/bloc-2/r-type/c13_persistance/#observable-2-choix-de-persistance","title":"\ud83d\udd0e Observable 2 : Choix de persistance","text":"<p>Suite \u00e0 l\u2019identification des donn\u00e9es \u00e0 persister dans l\u2019Observable 1, plusieurs solutions de stockage ont \u00e9t\u00e9 envisag\u00e9es afin de r\u00e9pondre aux besoins fonctionnels du projet tout en respectant les contraintes techniques, de performance et de s\u00e9curit\u00e9.</p> <p>Le tableau ci-dessous pr\u00e9sente un comparatif des solutions \u00e9tudi\u00e9es, avec leurs avantages, inconv\u00e9nients et cas d\u2019usage typiques :</p> Comparatif des solutions de persistance <p>La persistance des param\u00e8tres utilisateur est assur\u00e9e par un m\u00e9canisme simple et fiable bas\u00e9 sur un fichier de configuration texte.</p> <p>Les r\u00e9glages du jeu (tels que les options graphiques, les pr\u00e9f\u00e9rences de contr\u00f4le ou les param\u00e8tres de performance) sont sauvegard\u00e9s dans un fichier nomm\u00e9 rtype_settings.cfg. La fonction d\u00e9di\u00e9e \u00e0 cette op\u00e9ration \u00e9crit les param\u00e8tres actuels dans ce fichier \u00e0 chaque sauvegarde, garantissant ainsi la coh\u00e9rence entre l\u2019\u00e9tat du jeu et les donn\u00e9es persist\u00e9es.</p> <p>Chaque param\u00e8tre est enregistr\u00e9 sur une ligne distincte, selon un format clair et lisible de type cl\u00e9=valeur, ce qui facilite \u00e0 la fois la maintenance et l\u2019\u00e9ventuelle modification manuelle du fichier. Le fichier est g\u00e9n\u00e9r\u00e9 ou \u00e9cras\u00e9 \u00e0 chaque sauvegarde afin de refl\u00e9ter fid\u00e8lement l\u2019\u00e9tat courant des param\u00e8tres.</p>"},{"location":"rncp/bloc-2/r-type/c14_structures/","title":"C14 : Structures de Donn\u00e9es","text":""},{"location":"rncp/bloc-2/r-type/c14_structures/#observable-1-structures-de-donnees-utilisees","title":"\ud83d\udd0e Observable 1 : Structures de donn\u00e9es utilis\u00e9es","text":"<p>Le choix des structures de donn\u00e9es a \u00e9t\u00e9 guid\u00e9 par les besoins de performance, de maintenabilit\u00e9 et d\u2019\u00e9volutivit\u00e9 de l\u2019application. Diff\u00e9rents types de structures ont \u00e9t\u00e9 s\u00e9lectionn\u00e9s en fonction de leur complexit\u00e9 algorithmique et de leur usage dans le projet R-Type.</p>"},{"location":"rncp/bloc-2/r-type/c14_structures/#1-synthese-des-structures-utilisees","title":"1. Synth\u00e8se des structures utilis\u00e9es","text":"<ul> <li> <p>Structures ordonn\u00e9es (O(log\u202fO))</p> <ul> <li><code>std::map</code> : utilis\u00e9 pour stocker les scores des joueurs, permettant un acc\u00e8s ordonn\u00e9 et efficace.</li> </ul> </li> <li> <p>Structures s\u00e9quentielles (O(n))</p> <ul> <li><code>std::vector</code> : utilis\u00e9 pour la gestion des noms al\u00e9atoires des joueurs, facilitant l\u2019it\u00e9ration s\u00e9quentielle.</li> </ul> </li> <li> <p>Structures \u00e0 acc\u00e8s direct (O(1))</p> <ul> <li><code>std::unordered_map</code> : utilis\u00e9 pour le chargement rapide des textures gr\u00e2ce \u00e0 des lookups fr\u00e9quents.</li> <li><code>std::array</code> : utilis\u00e9 pour la r\u00e9cup\u00e9ration des touches, adapt\u00e9 \u00e0 un nombre fixe d\u2019\u00e9l\u00e9ments.</li> </ul> </li> </ul>"},{"location":"rncp/bloc-2/r-type/c14_structures/#observable-2-justification-des-choix","title":"\ud83d\udd0e Observable 2 : Justification des choix","text":"<p>Chaque structure de donn\u00e9es a \u00e9t\u00e9 choisie pour r\u00e9pondre \u00e0 un usage pr\u00e9cis, en tenant compte de la complexit\u00e9 et des besoins du projet.</p>"},{"location":"rncp/bloc-2/r-type/c14_structures/#1-detail-des-choix-et-justifications","title":"1. D\u00e9tail des choix et justifications","text":"<ul> <li> <p>std::map</p> <ul> <li>Usage : Gestion des scores</li> <li>Complexit\u00e9 : O(log\u202fO)</li> <li>Justification : Permet de maintenir un ordre sur les scores, essentiel pour les classements.</li> </ul> </li> <li> <p>std::vector</p> <ul> <li>Usage : Stockage des noms al\u00e9atoires des joueurs</li> <li>Complexit\u00e9 : O(n)</li> <li>Justification : Id\u00e9al pour l\u2019it\u00e9ration s\u00e9quentielle et la gestion dynamique de la taille.</li> </ul> </li> <li> <p>std::unordered_map</p> <ul> <li>Usage : Chargement des textures</li> <li>Complexit\u00e9 : O(1)</li> <li>Justification : Lookup tr\u00e8s rapide, adapt\u00e9 \u00e0 des acc\u00e8s fr\u00e9quents et non ordonn\u00e9s.</li> </ul> </li> <li> <p>std::array</p> <ul> <li>Usage : R\u00e9cup\u00e9ration des touches</li> <li>Complexit\u00e9 : O(1)</li> <li>Justification : Nombre de touches fixe, acc\u00e8s direct et rapide.</li> </ul> </li> </ul> <p>Ces choix de structures de donn\u00e9es permettent d\u2019optimiser les performances de l\u2019application tout en assurant une bonne maintenabilit\u00e9 et une \u00e9volutivit\u00e9 du code.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/","title":"C6 : Veille Technologique &amp; Accessibilit\u00e9","text":""},{"location":"rncp/bloc-2/r-type/c6_veille/#observable-1-etude-comparative","title":"\ud83d\udd0e Observable 1 : \u00c9tude comparative","text":"<p>Dans le cadre du projet R-Type, plusieurs choix techniques structurants devaient \u00eatre effectu\u00e9s afin de garantir la performance, la maintenabilit\u00e9 et l\u2019\u00e9volutivit\u00e9 du jeu. Cette \u00e9tude comparative vise \u00e0 analyser diff\u00e9rentes solutions techniques possibles et \u00e0 justifier les choix retenus en fonction des contraintes du projet.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#1-choix-de-la-bibliotheque-graphique-client","title":"1. Choix de la biblioth\u00e8que graphique \u2013 Client","text":"<p>C\u00f4t\u00e9 client, nous avions besoin d\u2019une biblioth\u00e8que capable de g\u00e9rer le rendu 2D temps r\u00e9el, les entr\u00e9es utilisateur et l\u2019audio, tout en restant compatible Linux et Windows, et suffisamment performante pour un jeu r\u00e9seau.</p> Comparatif des biblioth\u00e8ques graphiques <p>Nous avons compar\u00e9 principalement trois biblioth\u00e8ques : SFML, SDL2 et Raylib.</p> <p>Analyse : SFML offre une API tr\u00e8s simple et rapide \u00e0 prendre en main, mais elle est plus haut niveau et peut \u00eatre plus limitante pour un moteur fortement personnalis\u00e9. Raylib est tr\u00e8s accessible, mais moins mature pour des projets r\u00e9seau \u00e9volutifs. SDL2, en revanche, est plus bas niveau, mais offre un contr\u00f4le tr\u00e8s fin sur le rendu, les entr\u00e9es et l\u2019audio.</p> <p>Choix final : Nous avons choisi SDL2 car elle repr\u00e9sente un bon compromis entre performance, portabilit\u00e9 et ma\u00eetrise technique. M\u00eame si elle demande plus de code, elle s\u2019int\u00e8gre tr\u00e8s bien dans une architecture de moteur de jeu et permet une s\u00e9paration claire entre le rendu, la logique et le r\u00e9seau.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#2-architecture-du-moteur-de-jeu","title":"2. Architecture du moteur de jeu","text":"<p>Un des enjeux majeurs du projet \u00e9tait la s\u00e9paration des responsabilit\u00e9s entre les diff\u00e9rents syst\u00e8mes : rendu, logique de jeu et r\u00e9seau.</p> Comparaison des architectures logicielles  <p>Deux approches ont \u00e9t\u00e9 envisag\u00e9es : une architecture orient\u00e9e objet classique et une architecture de type ECS.</p> <p>Analyse : L\u2019approche orient\u00e9e objet est simple \u00e0 mettre en place, mais elle entra\u00eene rapidement un couplage fort entre les syst\u00e8mes. L\u2019architecture ECS permet au contraire de s\u00e9parer les donn\u00e9es, les comportements et les syst\u00e8mes, ce qui am\u00e9liore la lisibilit\u00e9, la performance et l\u2019\u00e9volutivit\u00e9.</p> <p>Choix final : Nous avons donc opt\u00e9 pour une architecture ECS afin de faciliter la gestion d\u2019un grand nombre d\u2019entit\u00e9s, comme les joueurs, les ennemis et les projectiles, tout en gardant un moteur modulaire et extensible. Ce choix permet \u00e9galement d\u2019envisager plus facilement l\u2019ajout de nouvelles fonctionnalit\u00e9s avanc\u00e9es par la suite.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#3-architecture-reseau-du-jeu","title":"3. Architecture r\u00e9seau du jeu","text":"<p>Un autre enjeu central du projet \u00e9tait la gestion du r\u00e9seau, car R-Type repose sur des \u00e9changes temps r\u00e9el entre le serveur et plusieurs clients.</p> Comparaison des solutions r\u00e9seau <p>Deux approches ont \u00e9t\u00e9 envisag\u00e9es : - une gestion r\u00e9seau bas niveau avec des sockets \u201cclassiques\u201d (TCP/UDP) - une solution plus abstraite bas\u00e9e sur une biblioth\u00e8que d\u00e9di\u00e9e, en l\u2019occurrence Boost.Asio</p> <p>Analyse : La gestion des sockets bas niveau permet un contr\u00f4le total des \u00e9changes, mais elle complexifie fortement le code. Elle demande de g\u00e9rer manuellement les connexions, les threads, la synchronisation et les erreurs r\u00e9seau, ce qui augmente le risque de bugs et rend la maintenance plus difficile. \u00c0 l\u2019inverse, Boost.Asio fournit une abstraction robuste pour le r\u00e9seau asynchrone. Elle permet de g\u00e9rer efficacement les communications non bloquantes, d\u2019am\u00e9liorer la lisibilit\u00e9 du code et de faciliter la scalabilit\u00e9 du serveur, tout en restant performante.</p> <p>Choix final : Nous avons choisi d\u2019utiliser Boost.Asio pour la partie r\u00e9seau. Ce choix nous permet de mettre en place une communication asynchrone propre et fiable entre le client et le serveur, adapt\u00e9e aux contraintes du temps r\u00e9el.</p> <p>Gr\u00e2ce \u00e0 Boost.Asio, le code r\u00e9seau est plus modulaire, plus maintenable et plus simple \u00e0 faire \u00e9voluer, ce qui est essentiel pour un jeu multijoueur comme R-Type. Ce choix s\u2019inscrit \u00e9galement dans une logique de r\u00e9duction de la dette technique et d\u2019anticipation des \u00e9volutions futures du projet.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#observable-2-identification-des-technologies-adaptees","title":"\ud83d\udd0e Observable 2 : Identification des technologies adapt\u00e9es","text":"<p>Dans le cadre du projet R-Type, il \u00e9tait essentiel de choisir des technologies r\u00e9pondant non seulement aux besoins fonctionnels et techniques du jeu, mais aussi aux crit\u00e8res d\u2019accessibilit\u00e9 pour les personnes en situation de handicap (PSH). Cette \u00e9tape vise \u00e0 identifier les outils, biblioth\u00e8ques et frameworks les plus adapt\u00e9s, en s\u2019appuyant sur la veille technologique, les standards du secteur et les recommandations r\u00e9glementaires, afin de garantir une solution p\u00e9renne, performante et accessible \u00e0 tous.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#1-game-accessibility-guidelines","title":"1. Game Accessibility Guidelines","text":"<p>Les Game Accessibility Guidelines constituent un ensemble de bonnes pratiques reconnues dans l\u2019industrie du jeu vid\u00e9o visant \u00e0 rendre les jeux accessibles au plus grand nombre, notamment aux personnes en situation de handicap (PSH). Elles couvrent diff\u00e9rents types de limitations, notamment visuelles, motrices, auditives et cognitives, et proposent des recommandations concr\u00e8tes telles que la personnalisation des contr\u00f4les, l\u2019adaptabilit\u00e9 de l\u2019interface ou la gestion des contrastes et du son.</p> <p>Ces guidelines permettent d\u2019anticiper les besoins des joueurs tout en r\u00e9duisant la dette technique li\u00e9e \u00e0 l\u2019accessibilit\u00e9.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#2-adaptations-mises-en-place-dans-le-projet","title":"2. Adaptations mises en place dans le projet","text":"<p>Dans le cadre du projet R-Type, plusieurs fonctionnalit\u00e9s ont \u00e9t\u00e9 impl\u00e9ment\u00e9es afin de respecter ces recommandations :</p> <ul> <li> <p>Taille des polices ajustable, garantissant une meilleure lisibilit\u00e9 quelle que soit la r\u00e9solution ou la taille de la fen\u00eatre</p> </li> <li> <p>Filtre daltonien, permettant d\u2019adapter les couleurs du jeu pour am\u00e9liorer la distinction des \u00e9l\u00e9ments visuels</p> </li> <li> <p>Personnalisation des touches, afin de s\u2019adapter aux contraintes motrices et aux pr\u00e9f\u00e9rences des joueurs</p> </li> <li> <p>Fen\u00eatre de jeu redimensionnable, sans impact sur la lisibilit\u00e9 ou la jouabilit\u00e9</p> </li> <li> <p>Ajustement ind\u00e9pendant du volume de la musique et des effets sonores</p> </li> </ul> <p>Ces choix am\u00e9liorent l\u2019accessibilit\u00e9 visuelle, motrice et auditive, tout en conservant une exp\u00e9rience de jeu coh\u00e9rente.</p>"},{"location":"rncp/bloc-2/r-type/c6_veille/#3-apport-de-sdl2-dans-laccessibilite","title":"3. Apport de SDL2 dans l\u2019accessibilit\u00e9","text":"<p>La biblioth\u00e8que SDL2 a jou\u00e9 un r\u00f4le central dans la mise en \u0153uvre de ces fonctionnalit\u00e9s. Elle offre un contr\u00f4le fin des entr\u00e9es clavier, du rendu graphique, de la gestion des fen\u00eatres et de l\u2019audio, ce qui facilite l\u2019impl\u00e9mentation de m\u00e9canismes d\u2019accessibilit\u00e9 personnalisables.</p> <p>De plus, sa portabilit\u00e9 multi-plateforme et sa flexibilit\u00e9 permettent d\u2019adapter l\u2019interface et les interactions sans d\u00e9pendre de contraintes impos\u00e9es par un framework trop abstrait. Le choix de SDL2 s\u2019inscrit ainsi dans une d\u00e9marche de ma\u00eetrise technique, de p\u00e9rennit\u00e9 et de conformit\u00e9 aux bonnes pratiques d\u2019accessibilit\u00e9, en accord avec les Game Accessibility Guidelines.</p>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/","title":"C7 - S\u00c9CURIT\u00c9 INFORMATIQUE R-TYPE","text":"<p>R-Type utilise UDP pour la communication r\u00e9seau temps r\u00e9el. Dans ce cadre, une attention particuli\u00e8re est port\u00e9e \u00e0 la s\u00e9curit\u00e9 des \u00e9changes et \u00e0 la robustesse du serveur face \u00e0 des clients potentiellement malveillants.</p> <p>Une partie de cette d\u00e9marche repose sur l\u2019analyse de CVE (Common Vulnerabilities and Exposures).</p> <p>\ud83d\udd0e Qu\u2019est-ce qu\u2019une CVE ? Une CVE est une vuln\u00e9rabilit\u00e9 de s\u00e9curit\u00e9 publique, document\u00e9e et r\u00e9f\u00e9renc\u00e9e de mani\u00e8re unique, affectant un logiciel, une biblioth\u00e8que ou un outil. Chaque CVE d\u00e9crit la nature de la faille, les versions concern\u00e9es, son niveau de s\u00e9v\u00e9rit\u00e9 et les correctifs associ\u00e9s.</p> <p>Dans ce projet, seules les CVE pertinentes pour l\u2019architecture R-Type ont \u00e9t\u00e9 retenues afin de rester coh\u00e9rent avec le p\u00e9rim\u00e8tre du jeu.</p>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#observable-1-etude-des-failles-de-securite","title":"\ud83d\udd0e Observable 1 : \u00c9TUDE DES FAILLES DE S\u00c9CURIT\u00c9","text":""},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#demarche","title":"D\u00e9marche","text":"<p>Afin de rester lisible et pertinent, l\u2019\u00e9tude se concentre volontairement sur trois cas repr\u00e9sentatifs :</p> <ul> <li>une vuln\u00e9rabilit\u00e9 de biblioth\u00e8que graphique,</li> <li>une vuln\u00e9rabilit\u00e9 r\u00e9seau li\u00e9e aux d\u00e9pendances,</li> <li>une limitation inh\u00e9rente au protocole UDP.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#1-cve-2022-4743-sdl2-buffer-overflow","title":"1\ufe0f\u20e3 CVE-2022-4743 \u2013 SDL2 Buffer Overflow","text":"<p>Technologie : SDL2 (Simple DirectMedia Layer) S\u00e9v\u00e9rit\u00e9 : \u00c9lev\u00e9e (7.8) Versions affect\u00e9es : SDL2 &lt; 2.0.22 Version utilis\u00e9e : 2.28.3 \u2705</p> <p>Description : Cette CVE d\u00e9crit un d\u00e9passement de m\u00e9moire tampon lors du chargement d\u2019images XPM via <code>SDL_Image</code>. Une image sp\u00e9cialement forg\u00e9e peut provoquer un crash du client, voire une ex\u00e9cution de code arbitraire.</p> <p>Mesure appliqu\u00e9e :</p> <ul> <li>Mise \u00e0 jour vers une version corrig\u00e9e de SDL2</li> <li>Gestion stricte des d\u00e9pendances via Conan</li> </ul> <p>Statut : \u2705 Corrig\u00e9e</p>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#2-cve-2020-13616-boostasio-tls-hostname-bypass","title":"2\ufe0f\u20e3 CVE-2020-13616 \u2013 Boost.Asio TLS Hostname Bypass","text":"<p>Technologie : Boost.Asio S\u00e9v\u00e9rit\u00e9 : Moyenne (5.9) Versions affect\u00e9es : Boost &lt; 1.73.0 Version utilis\u00e9e : 1.82.0 \u2705</p> <p>Description : Cette vuln\u00e9rabilit\u00e9 concerne une validation incorrecte du nom d\u2019h\u00f4te lors d\u2019une connexion TLS, pouvant permettre une attaque de type Man-in-the-Middle.</p> <p>Analyse dans R-Type : R-Type utilise exclusivement UDP brut, sans chiffrement TLS, afin de garantir une latence minimale compatible avec un jeu temps r\u00e9el.</p> <p>D\u00e9cision technique :</p> <ul> <li>TLS non utilis\u00e9 volontairement (trade-off performance / s\u00e9curit\u00e9)</li> <li>S\u00e9curit\u00e9 assur\u00e9e par un serveur autoritaire et une validation stricte des paquets</li> </ul> <p>Statut : \u26a0\ufe0f Non applicable</p>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#3-limitation-udp-fragmentation-des-paquets-rfc-768","title":"3\ufe0f\u20e3 Limitation UDP \u2013 Fragmentation des paquets (RFC 768)","text":"<p>Technologie : UDP Type : Limitation inh\u00e9rente au protocole</p> <p>Description : Les paquets UDP d\u00e9passant la MTU r\u00e9seau (~1500 octets) sont fragment\u00e9s au niveau IP. Cette fragmentation augmente les risques de pertes et peut \u00eatre exploit\u00e9e pour des attaques de type d\u00e9ni de service.</p> <p>Mesure appliqu\u00e9e :</p> <ul> <li>Taille maximale des paquets fix\u00e9e \u00e0 1400 octets</li> <li>Rejet des paquets fragment\u00e9s</li> </ul> <p>B\u00e9n\u00e9fices :</p> <ul> <li>R\u00e9duction du risque de DoS</li> <li>Comportement r\u00e9seau pr\u00e9dictible</li> <li>Stabilit\u00e9 accrue du serveur</li> </ul> <p>Statut : \u2705 Mitig\u00e9 par conception</p>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#bonnes-pratiques-de-securite-implementees","title":"Bonnes pratiques de s\u00e9curit\u00e9 impl\u00e9ment\u00e9es","text":"<ul> <li>Validation serveur syst\u00e9matique des actions client</li> <li>Serveur autoritaire (le client n\u2019est jamais consid\u00e9r\u00e9 comme fiable)</li> <li>Contr\u00f4le des dimensions et valeurs re\u00e7ues (clamping)</li> <li>Isolation stricte des parties (rooms)</li> </ul>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#resume-c71","title":"R\u00e9sum\u00e9 C7.1","text":"<ul> <li>3 risques de s\u00e9curit\u00e9 analys\u00e9s, dont 1 CVE critique</li> <li>D\u00e9cisions techniques justifi\u00e9es selon le contexte temps r\u00e9el</li> <li>Mesures concr\u00e8tes impl\u00e9ment\u00e9es et v\u00e9rifiables dans le code</li> </ul>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#observable-2-veille-securite-informatique","title":"\ud83d\udd0e Observable 2 : VEILLE S\u00c9CURIT\u00c9 INFORMATIQUE","text":""},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#demarche-de-veille","title":"D\u00e9marche de veille","text":"<p>La veille s\u00e9curit\u00e9 repose sur des sources reconnues :</p> <ul> <li>Base CVE (NVD \u2013 NIST)</li> <li>OWASP (principes de s\u00e9curit\u00e9 applicative)</li> <li>RFC r\u00e9seau (UDP \u2013 RFC 768)</li> <li>Retours d\u2019exp\u00e9rience du domaine du jeu vid\u00e9o multijoueur</li> </ul>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#resultats","title":"R\u00e9sultats","text":"<ul> <li>Identification de vuln\u00e9rabilit\u00e9s pertinentes pour le projet</li> <li>Mise \u00e0 jour proactive des d\u00e9pendances</li> <li>Int\u00e9gration de bonnes pratiques adapt\u00e9es au contexte jeu r\u00e9seau</li> </ul>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#pistes-damelioration","title":"Pistes d\u2019am\u00e9lioration","text":"<ul> <li>Signature l\u00e9g\u00e8re des paquets (HMAC)</li> <li>Num\u00e9rotation des paquets (anti-replay)</li> <li>Rate limiting c\u00f4t\u00e9 serveur</li> </ul>"},{"location":"rncp/bloc-2/r-type/c7_securite-rtype/#message-cle","title":"Message cl\u00e9","text":"<p>\u00ab Le serveur doit rester autoritaire. Le client ne doit jamais \u00eatre digne de confiance. \u00bb</p>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/","title":"C8 : Prototypage &amp; Contraintes du Projet","text":""},{"location":"rncp/bloc-2/r-type/c8_prototypage/#observable-1-demarche-de-prototypage","title":"\ud83d\udd0e Observable 1 : D\u00e9marche de prototypage","text":"<p>Le prototypage a \u00e9t\u00e9 une \u00e9tape cl\u00e9 dans le d\u00e9veloppement du projet R-Type. Il a permis de valider les choix techniques, d\u2019anticiper les difficult\u00e9s et d\u2019optimiser l\u2019architecture du jeu avant la mise en production.</p>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#1-evolution-des-prototypes","title":"1. \u00c9volution des prototypes","text":"<p>Le projet s\u2019est articul\u00e9 autour de plusieurs prototypes successifs, chacun r\u00e9pondant \u00e0 des objectifs pr\u00e9cis :</p> <ul> <li>Prototype 1 : Mise en place d\u2019un ECS minimal et d\u00e9veloppement d\u2019un serveur simple.</li> <li>Prototype 2 : Ajout d\u2019une fen\u00eatre graphique en SFML, mise en place d\u2019un serveur plus complexe et utilisation partielle de l\u2019ECS.</li> <li>Probl\u00e8mes identifi\u00e9s : L\u2019ECS n\u2019est pas exploit\u00e9 pleinement, faible modularit\u00e9 et forte d\u00e9pendance aux biblioth\u00e8ques externes.</li> </ul> Sch\u00e9ma d\u2019\u00e9volution des prototypes"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#2-prototype-final","title":"2. Prototype final","text":"<p>Suite \u00e0 l\u2019analyse des prototypes pr\u00e9c\u00e9dents, le prototype final a int\u00e9gr\u00e9 plusieurs am\u00e9liorations majeures :</p> <ul> <li>Utilisation compl\u00e8te de l\u2019ECS pour une meilleure modularit\u00e9 et \u00e9volutivit\u00e9.</li> <li>Abstraction des biblioth\u00e8ques r\u00e9seau et graphiques afin de limiter la d\u00e9pendance et faciliter la maintenance.</li> <li>Remplacement de la SFML par SDL2 pour le rendu graphique, conform\u00e9ment aux choix techniques valid\u00e9s lors de la veille.</li> </ul> <p>Ce processus it\u00e9ratif a permis d\u2019aboutir \u00e0 une architecture robuste, adapt\u00e9e aux besoins du projet et facilement extensible.</p>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#observable-2-comparatif-des-prototypes","title":"\ud83d\udd0e Observable 2 : Comparatif des prototypes","text":"<p>Le d\u00e9veloppement du projet R-Type a \u00e9t\u00e9 guid\u00e9 par plusieurs contraintes majeures, qui ont influenc\u00e9 les choix techniques et organisationnels.</p>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#1-synthese-des-contraintes","title":"1. Synth\u00e8se des contraintes","text":"Tableau des contraintes du projet"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#2-impact-sur-le-prototypage","title":"2. Impact sur le prototypage","text":"<p>Chaque prototype a eu un impact sp\u00e9cifique sur le projet, avec ses avantages et ses limites :</p>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#prototype-1","title":"Prototype 1","text":"<ul> <li>Avantages : Mise en place rapide d\u2019une structure ECS minimale, simplicit\u00e9 du serveur, bonne base pour exp\u00e9rimenter l\u2019architecture.</li> <li>Probl\u00e8mes : Fonctionnalit\u00e9s limit\u00e9es, absence d\u2019interface graphique, peu de modularit\u00e9, difficile \u00e0 \u00e9tendre pour des besoins avanc\u00e9s.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#prototype-2","title":"Prototype 2","text":"<ul> <li>Avantages : Ajout d\u2019une interface graphique (SFML), serveur plus complexe, d\u00e9but d\u2019int\u00e9gration de l\u2019ECS dans la logique du jeu.</li> <li>Probl\u00e8mes : L\u2019ECS n\u2019est pas exploit\u00e9 pleinement, d\u00e9pendance forte \u00e0 SFML, modularit\u00e9 insuffisante, complexit\u00e9 accrue pour la maintenance.</li> </ul>"},{"location":"rncp/bloc-2/r-type/c8_prototypage/#prototype-final","title":"Prototype final","text":"<ul> <li>Avantages : Utilisation compl\u00e8te de l\u2019ECS, abstraction des biblioth\u00e8ques r\u00e9seau et graphiques, remplacement de SFML par SDL2, architecture modulaire et \u00e9volutive, meilleure maintenabilit\u00e9 et accessibilit\u00e9.</li> <li>Probl\u00e8mes : Demande un effort de refonte, complexit\u00e9 technique plus \u00e9lev\u00e9e, n\u00e9cessit\u00e9 d\u2019une bonne organisation du code.</li> </ul> <p>Ce retour d\u2019exp\u00e9rience sur les prototypes a permis d\u2019orienter les choix techniques vers une solution robuste, \u00e9volutive et adapt\u00e9e aux contraintes du projet.</p>"},{"location":"rncp/bloc-2/r-type/c9_architecture/","title":"Architecture Logicielle &amp; Patterns ECS","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#choix-darchitecture","title":"Choix d'Architecture","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#architecture-clientserveur-ecs","title":"Architecture Client/Serveur + ECS","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#justification-du-pattern-ecs","title":"Justification du pattern ECS","text":"Avantage B\u00e9n\u00e9fice \ud83d\udd00 D\u00e9couplage Donn\u00e9es (Composants) \u2260 Logique (Syst\u00e8mes) \ud83d\udce6 Extensibilit\u00e9 Nouvelle feature = Syst\u00e8me + Composants \u26a1 Performance Data-oriented design, cache-friendly \ud83e\uddea Testabilit\u00e9 Chaque syst\u00e8me ind\u00e9pendant et isolable"},{"location":"rncp/bloc-2/r-type/c9_architecture/#schema-architectural","title":"Sch\u00e9ma Architectural","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502          CLIENT (Rendu &amp; Entr\u00e9es)                \u2502\n\u2502  InputManager \u2190\u2192 UDP \u2190\u2192 Renderer                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2195 Synchronisation\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    SERVER (Autorit\u00e9 Logique - ECS Engine)        \u2502\n\u2502                                                  \u2502\n\u2502  UDP Protocol \u2190\u2192 Game Loop \u2190\u2192 ECS Engine         \u2502\n\u2502                              \u251c\u2500 SystemManager    \u2502\n\u2502                              \u251c\u2500 EntityManager    \u2502\n\u2502                              \u2514\u2500 ComponentManager \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#pipeline-moteur","title":"Pipeline Moteur","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#engineupdate-cur-du-systeme","title":"<code>Engine::update()</code> \u2013 C\u0153ur du Syst\u00e8me","text":"<p>S\u00e9quence d'ex\u00e9cution garantie:</p> <pre><code>void Engine::update() {\n  if (!initialized_) return;\n\n  // 1\ufe0f\u20e3 Mise \u00e0 jour du timing\n  time_manager_.update();\n  float delta_time = time_manager_.get_delta_time();\n\n  // 2\ufe0f\u20e3 Ex\u00e9cution de tous les syst\u00e8mes (ordre d\u00e9terministe)\n  system_manager_.update_all_systems(delta_time);\n\n  // 3\ufe0f\u20e3 Cleanup automatique des entit\u00e9s marqu\u00e9es\n}\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#ordre-dexecution-des-systemes","title":"Ordre d'Ex\u00e9cution des Syst\u00e8mes","text":"<pre><code>graph LR\n  A[\"1. InputSystem\"] \u2192 B[\"2. MovementSystem\"]\n  B \u2192 C[\"3. EnemyAISystem\"]\n  C \u2192 D[\"4. PhysicsSystem\"]\n  D \u2192 E[\"5. NetworkSyncSystem\"]\n  E \u2192 F[\"6. RenderSystem&lt;br/&gt;(Client Only)\"]\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#pattern-ecs-implementation","title":"Pattern ECS - Impl\u00e9mentation","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#template-system","title":"Template System <pre><code>template &lt;typename... ComponentTypes&gt;\nclass System : public ISystem {\n public:\n  void update(float dt) override {\n  for (EntityId e : entity_manager_-&gt;get_entities())\n    if (has_required_components(e))\n    update_entity(e, dt);  // Traite seulement les entit\u00e9s valides\n  }\n};\n</code></pre>","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#exemple-concret-playermovementsystem","title":"Exemple Concret \u2013 <code>PlayerMovementSystem</code>","text":"<p>Cet exemple illustre comment un syst\u00e8me filtre et traite les entit\u00e9s:</p> <pre><code>class PlayerMovementSystem : public System&lt;Transform, Velocity, PlayerInput, MovementStats&gt; {\n  void update_entity(EntityId e, float dt) override {\n  // R\u00e9cup\u00e8re les composants requis\n  auto* transform = get_component&lt;Transform&gt;(e);\n  auto* velocity = get_component&lt;Velocity&gt;(e);\n  auto* input = get_component&lt;PlayerInput&gt;(e);\n\n  // Applique la physique\n  velocity-&gt;x = input-&gt;x * movement_speed_;\n  transform-&gt;x += velocity-&gt;x * dt;\n\n  // Clamp aux limites\n  transform-&gt;x = std::clamp(transform-&gt;x, 0.f, screen_width_);\n  }\n};\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#integration-technique","title":"Int\u00e9gration Technique","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#gestion-du-lifecycle-injection-de-dependances","title":"Gestion du Lifecycle &amp; Injection de D\u00e9pendances <p>Approche Service Locator l\u00e9ger via SystemManager:</p> <pre><code>template &lt;typename T, typename... Args&gt;\nT* SystemManager::register_system(Args&amp;&amp;... args) {\n  auto system = std::make_unique&lt;T&gt;(std::forward&lt;Args&gt;(args)...);\n\n  // Injection des d\u00e9pendances\n  system-&gt;set_component_manager(&amp;component_manager_);\n  system-&gt;set_entity_manager(&amp;entity_manager_);\n\n  // Hook d'initialisation\n  system-&gt;initialize();\n\n  systems_.push_back(std::move(system));\n  return system.get();\n}\n</code></pre>","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#avantages-de-cette-approche","title":"Avantages de cette Approche","text":"<p>\u2705 Couplage Minimal \u2013 Syst\u00e8mes ne d\u00e9pendent que des interfaces \u2705 Extensibilit\u00e9 \u2013 Pas de d\u00e9pendance crois\u00e9e entre syst\u00e8mes \u2705 Lifecycle Garanti \u2013 S\u00e9quence init \u2192 update \u2192 shutdown ma\u00eetris\u00e9e  </p>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#registry-composants-allocation-automatique-des-type-ids","title":"Registry Composants \u2013 Allocation Automatique des Type IDs <pre><code>template &lt;typename T&gt;\nclass ComponentTypeRegistry {\n public:\n  static ComponentTypeId get_type_id() {\n  // \ud83d\udd10 Thread-safe : variable locale statique\n  static ComponentTypeId type_id = allocate_component_type_id();\n  return type_id;\n  }\n};\n\ninline ComponentTypeId allocate_component_type_id() {\n  static ComponentTypeId next_id = 0;\n  return ++next_id;  // Incr\u00e9mentation atomique\n}\n</code></pre>","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#benefice-extensibilite-zero-couplage","title":"B\u00e9n\u00e9fice : Extensibilit\u00e9 Z\u00e9ro-Couplage","text":"Action Impact Cr\u00e9er une classe composant Type ID g\u00e9n\u00e9r\u00e9 automatiquement Modifier le code core ECS \u274c Pas n\u00e9cessaire IDs uniques et d\u00e9terministes \u2705 Garanti"},{"location":"rncp/bloc-2/r-type/c9_architecture/#integration-serveur","title":"Int\u00e9gration Serveur","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#initialisation-du-serveur-de-jeu","title":"Initialisation du Serveur de Jeu <pre><code>GameServer::GameServer(Asamio::IoContext&amp; io, uint16_t port)\n  : socket_(io, UdpEndpoint(UdpProtocol::v4(), port)) {\n\n  engine_.initialize();\n\n  // Enregistrement des syst\u00e8mes\n  movement_system_ = engine_.register_system&lt;MovementSystem&gt;();\n  enemy_ai_system_ = engine_.register_system&lt;EnemyAISystem&gt;();\n  physics_system_ = engine_.register_system&lt;PhysicsSystem&gt;();\n  network_system_ = engine_.register_system&lt;NetworkSyncSystem&gt;();\n\n  startGameLoop();  // Boucle asynchrone UDP\n}\n</code></pre>","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#flux-de-traitement-reseau","title":"Flux de Traitement R\u00e9seau","text":"<pre><code>UDP Packet Re\u00e7u\n    \u2193\nValidation Headers\n    \u2193\nParsing Payload\n    \u2193\nDispatch \u2192 Syst\u00e8mes (Input, Spawn, etc.)\n    \u2193\nBroadcast State Updates \u2192 Clients\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#organisation-modulaire","title":"Organisation Modulaire","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#structure-des-dossiers-par-domaine","title":"Structure des Dossiers par Domaine <pre><code>src/\n\u251c\u2500\u2500 engine/                    \u2190 Infrastructure ECS (z\u00e9ro d\u00e9pendance)\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u251c\u2500\u2500 Engine.h/cpp\n\u2502   \u2502   \u251c\u2500\u2500 System.h\n\u2502   \u2502   \u251c\u2500\u2500 Entity.h\n\u2502   \u2502   \u2514\u2500\u2500 ComponentManager.h\n\u2502   \u2514\u2500\u2500 registry/\n\u2502       \u2514\u2500\u2500 ComponentTypeRegistry.h\n\u2502\n\u251c\u2500\u2500 game/                      \u2190 Logique applicative\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2502   \u251c\u2500\u2500 Transform.h\n\u2502   \u2502   \u251c\u2500\u2500 Velocity.h\n\u2502   \u2502   \u251c\u2500\u2500 Enemy.h\n\u2502   \u2502   \u2514\u2500\u2500 Health.h\n\u2502   \u2514\u2500\u2500 systems/\n\u2502       \u251c\u2500\u2500 MovementSystem.h\n\u2502       \u251c\u2500\u2500 EnemyAISystem.h\n\u2502       \u2514\u2500\u2500 ProjectileSystem.h\n\u2502\n\u251c\u2500\u2500 client/                    \u2190 Rendu + Entr\u00e9es utilisateur\n\u2502   \u251c\u2500\u2500 Graphics/\n\u2502   \u2502   \u251c\u2500\u2500 Renderer.h\n\u2502   \u2502   \u2514\u2500\u2500 InputManager.h\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2502\n\u251c\u2500\u2500 server/                    \u2190 R\u00e9seau autoritaire\n\u2502   \u251c\u2500\u2500 GameServer.h/cpp\n\u2502   \u251c\u2500\u2500 Protocol.h\n\u2502   \u2514\u2500\u2500 RoomManager.h\n\u2502\n\u2514\u2500\u2500 common/                    \u2190 Partag\u00e9 client/server\n  \u251c\u2500\u2500 Constants.h\n  \u2514\u2500\u2500 NetworkProtocol.h\n</code></pre>","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#dependances-unidirectionnelles","title":"D\u00e9pendances Unidirectionnelles","text":"<pre><code>graph BT\n  Engine[\"\ud83d\udd27 engine/\"]\n  Game[\"\ud83c\udfae game/\"]\n  Client[\"\ud83d\udc41\ufe0f client/\"]\n  Server[\"\ud83d\udda5\ufe0f server/\"]\n\n  Game --&gt;|d\u00e9pend de| Engine\n  Client --&gt;|d\u00e9pend de| Game\n  Client --&gt;|d\u00e9pend de| Engine\n  Server --&gt;|d\u00e9pend de| Game\n  Server --&gt;|d\u00e9pend de| Engine\n\n  style Engine fill:#e1f5ff\n  style Game fill:#f3e5f5\n  style Client fill:#fff3e0\n  style Server fill:#e8f5e9\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#perennite-extensibilite","title":"P\u00e9rennit\u00e9 &amp; Extensibilit\u00e9","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#ajout-dune-nouvelle-feature-systeme-de-shield","title":"Ajout d'une Nouvelle Feature : Syst\u00e8me de Shield <p>Scenario complet (z\u00e9ro modification du code existant):</p>","text":""},{"location":"rncp/bloc-2/r-type/c9_architecture/#etape-1-creer-les-composants","title":"\u00c9tape 1 : Cr\u00e9er les Composants","text":"<pre><code>// components/Shield.h\nstruct Shield {\n  float health = 100.f;\n  float max_health = 100.f;\n  float recharge_rate = 25.f;  // par seconde\n};\n\nstruct ShieldRenderer {\n  uint32_t shader_id;\n  glm::vec3 color;\n};\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#etape-2-implementer-le-systeme","title":"\u00c9tape 2 : Impl\u00e9menter le Syst\u00e8me","text":"<pre><code>// systems/ShieldSystem.h\nclass ShieldSystem : public System&lt;Shield, Health&gt; {\n private:\n  NetworkSyncSystem* network_sync_;\n\n public:\n  void initialize() override {\n  network_sync_ = get_system&lt;NetworkSyncSystem&gt;();\n  }\n\n  void update_entity(EntityId e, float dt) override {\n  auto* shield = get_component&lt;Shield&gt;(e);\n\n  // Recharge progressive\n  shield-&gt;health = std::min(\n    shield-&gt;health + shield-&gt;recharge_rate * dt,\n    shield-&gt;max_health\n  );\n\n  // Sync serveur \u2192 clients\n  if (network_sync_)\n    network_sync_-&gt;mark_entity_dirty(e);\n  }\n};\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#etape-3-enregistrer-dans-lengine","title":"\u00c9tape 3 : Enregistrer dans l'Engine","text":"<pre><code>// main.cpp ou GameServer.cpp\nengine_.register_system&lt;ShieldSystem&gt;();\n</code></pre>"},{"location":"rncp/bloc-2/r-type/c9_architecture/#resultat","title":"R\u00e9sultat","text":"M\u00e9trique Avant Apr\u00e8s Lignes modifi\u00e9es dans engine/ 0 0 Lignes modifi\u00e9es dans game/ 0 0 Couplage crois\u00e9 \u274c \u274c Testabilit\u00e9 du nouveau code \u2705 \u2705"},{"location":"rncp/bloc-2/r-type/c9_architecture/#resume-des-patterns","title":"\ud83d\udcca R\u00e9sum\u00e9 des Patterns","text":"Pattern Usage B\u00e9n\u00e9fice ECS S\u00e9paration donn\u00e9es/logique Maintenabilit\u00e9, Performance Service Locator Injection de d\u00e9pendances Couplage minimal Template Registry Allocation automatique IDs Extensibilit\u00e9 Unidirectional Dependencies Architecture modulaire Testabilit\u00e9, Isolabilit\u00e9"},{"location":"rncp/bloc-2/r-type/conclusion/","title":"Conclusion","text":""},{"location":"rncp/bloc-2/r-type/conclusion/#conclusion","title":"Conclusion","text":"<p>Le d\u00e9veloppement de notre jeu R-Type a \u00e9t\u00e9 une exp\u00e9rience formatrice, illustrant concr\u00e8tement l'application des comp\u00e9tences vis\u00e9es par le r\u00e9f\u00e9rentiel RNCP. Ce projet nous a permis de mettre en \u0153uvre des savoir-faire techniques tels que la conception d'architectures logicielles robustes, l'impl\u00e9mentation d'algorithmes complexes, la gestion de la persistance des donn\u00e9es et l'int\u00e9gration de mesures de s\u00e9curit\u00e9 adapt\u00e9es.</p> <p>Au-del\u00e0 des aspects techniques, la r\u00e9alisation de ce jeu a favoris\u00e9 le travail en \u00e9quipe, la gestion de projet, la r\u00e9solution de probl\u00e8mes et l'adaptabilit\u00e9, comp\u00e9tences transversales essentielles dans le cadre du RNCP. En somme, ce projet a constitu\u00e9 un terrain d'apprentissage complet, nous pr\u00e9parant efficacement aux exigences professionnelles du secteur du d\u00e9veloppement logiciel.</p>"}]}